import type { Express } from "express";
import { createServer, type Server } from "http";
import OpenAI from "openai";
import { generateCodeRequestSchema, exportRequestSchema } from "@shared/schema";

// Lazy initialization of OpenAI client
let openaiClient: OpenAI | null = null;

function getOpenAI(): OpenAI {
  if (!openaiClient) {
    if (!process.env.OPENAI_API_KEY) {
      throw new Error("OPENAI_API_KEY environment variable is not set. Please add your OpenAI API key to use code generation.");
    }
    // the newest OpenAI model is "gpt-5" which was released August 7, 2025
    openaiClient = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
  }
  return openaiClient;
}

function serializeGraphToPrompt(graph: {
  nodes: { id: string; type: string; label: string; params: Record<string, unknown>; position: { x: number; y: number } }[];
  edges: { id: string; source: string; sourceHandle: string; target: string; targetHandle: string }[];
  metadata?: { name?: string; description?: string; framework?: string };
}, framework: string): string {
  const nodeMap = new Map(graph.nodes.map(n => [n.id, n]));
  
  const sortedNodes = [...graph.nodes].sort((a, b) => {
    const aIsSource = graph.edges.some(e => e.source === a.id);
    const aIsTarget = graph.edges.some(e => e.target === a.id);
    const bIsSource = graph.edges.some(e => e.source === b.id);
    const bIsTarget = graph.edges.some(e => e.target === b.id);
    
    if (!aIsTarget && bIsTarget) return -1;
    if (aIsTarget && !bIsTarget) return 1;
    return a.position.y - b.position.y;
  });

  const nodeDescriptions = sortedNodes.map(node => {
    const paramStr = Object.entries(node.params)
      .map(([k, v]) => `${k}=${JSON.stringify(v)}`)
      .join(", ");
    return `- ${node.id} (${node.label}): ${node.type}(${paramStr})`;
  }).join("\n");

  const connectionDescriptions = graph.edges.map(edge => {
    const sourceNode = nodeMap.get(edge.source);
    const targetNode = nodeMap.get(edge.target);
    return `- ${sourceNode?.label || edge.source}.${edge.sourceHandle} -> ${targetNode?.label || edge.target}.${edge.targetHandle}`;
  }).join("\n");

  const frameworkImports: Record<string, string> = {
    pytorch: "import torch\nimport torch.nn as nn\nimport torch.nn.functional as F",
    tensorflow: "import tensorflow as tf\nfrom tensorflow import keras\nfrom tensorflow.keras import layers",
    jax: "import jax\nimport jax.numpy as jnp\nfrom flax import linen as nn",
  };

  return `Generate a ${framework.toUpperCase()} neural network model based on the following architecture:

NODES (layers/operations):
${nodeDescriptions}

DATA FLOW (connections):
${connectionDescriptions || "Sequential flow through nodes in order listed"}

REQUIREMENTS:
1. Create a proper neural network class that implements this architecture
2. Use proper ${framework} conventions and best practices
3. Handle the data flow correctly, especially for residual/skip connections if present
4. Include type hints and docstrings
5. The forward method should properly route tensors through the network
6. Include example usage showing how to instantiate and run the model

Start with:
${frameworkImports[framework] || frameworkImports.pytorch}

Generate clean, production-ready code. Only output the Python code, no explanations.`;
}

function generateNodeMapping(code: string, nodes: { id: string; label: string }[]): Record<string, { startLine: number; endLine: number }> {
  const mapping: Record<string, { startLine: number; endLine: number }> = {};
  const lines = code.split("\n");
  
  nodes.forEach(node => {
    const labelLower = node.label.toLowerCase().replace(/[^a-z0-9]/g, "");
    const idMatch = node.id.replace("node_", "");
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].toLowerCase();
      if (
        line.includes(`self.${labelLower}`) ||
        line.includes(`self.layer${idMatch}`) ||
        line.includes(node.label.toLowerCase())
      ) {
        if (!mapping[node.id]) {
          mapping[node.id] = { startLine: i + 1, endLine: i + 1 };
        } else {
          mapping[node.id].endLine = i + 1;
        }
      }
    }
  });
  
  return mapping;
}

function generateJupyterNotebook(code: string): object {
  return {
    nbformat: 4,
    nbformat_minor: 5,
    metadata: {
      kernelspec: {
        display_name: "Python 3",
        language: "python",
        name: "python3",
      },
      language_info: {
        name: "python",
        version: "3.10.0",
      },
    },
    cells: [
      {
        cell_type: "markdown",
        metadata: {},
        source: ["# Neural Network Architecture\n", "\n", "Generated by Neuro-Canvas"],
      },
      {
        cell_type: "code",
        metadata: {},
        source: ["# Install dependencies if needed\n", "# !pip install torch"],
        execution_count: null,
        outputs: [],
      },
      {
        cell_type: "code",
        metadata: {},
        source: code.split("\n").map((line, i, arr) => 
          i === arr.length - 1 ? line : line + "\n"
        ),
        execution_count: null,
        outputs: [],
      },
      {
        cell_type: "markdown",
        metadata: {},
        source: ["## Training Loop\n", "\n", "Add your training code below:"],
      },
      {
        cell_type: "code",
        metadata: {},
        source: [
          "# Example training loop\n",
          "# optimizer = torch.optim.Adam(model.parameters(), lr=1e-3)\n",
          "# criterion = nn.CrossEntropyLoss()\n",
          "#\n",
          "# for epoch in range(num_epochs):\n",
          "#     for batch in dataloader:\n",
          "#         optimizer.zero_grad()\n",
          "#         outputs = model(batch)\n",
          "#         loss = criterion(outputs, targets)\n",
          "#         loss.backward()\n",
          "#         optimizer.step()\n",
        ],
        execution_count: null,
        outputs: [],
      },
    ],
  };
}

export async function registerRoutes(
  httpServer: Server,
  app: Express
): Promise<Server> {
  
  app.post("/api/generate-code", async (req, res) => {
    try {
      const parsed = generateCodeRequestSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ 
          error: "Invalid request", 
          details: parsed.error.errors 
        });
      }

      const { graph, framework } = parsed.data;
      
      if (graph.nodes.length === 0) {
        return res.status(400).json({ error: "Graph has no nodes" });
      }

      const prompt = serializeGraphToPrompt(graph, framework);

      const response = await getOpenAI().chat.completions.create({
        model: "gpt-5",
        messages: [
          {
            role: "system",
            content: `You are an expert ML engineer who writes clean, production-ready ${framework} code. Generate only valid Python code without markdown formatting or code blocks. The code should be immediately executable.`,
          },
          {
            role: "user",
            content: prompt,
          },
        ],
        max_completion_tokens: 4096,
      });

      let code = response.choices[0]?.message?.content || "";
      
      code = code.replace(/```python\n?/g, "").replace(/```\n?/g, "").trim();

      const nodeMapping = generateNodeMapping(code, graph.nodes);

      res.json({
        code,
        framework,
        nodeMapping,
      });
    } catch (error) {
      console.error("Code generation error:", error);
      res.status(500).json({ 
        error: "Failed to generate code",
        message: error instanceof Error ? error.message : "Unknown error",
      });
    }
  });

  app.post("/api/export", async (req, res) => {
    try {
      const parsed = exportRequestSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ 
          error: "Invalid request", 
          details: parsed.error.errors 
        });
      }

      const { code, format, filename = "neural_network" } = parsed.data;

      if (format === "py") {
        res.setHeader("Content-Type", "text/x-python");
        res.setHeader("Content-Disposition", `attachment; filename="${filename}.py"`);
        res.send(code);
      } else if (format === "ipynb") {
        const notebook = generateJupyterNotebook(code);
        res.setHeader("Content-Type", "application/json");
        res.setHeader("Content-Disposition", `attachment; filename="${filename}.ipynb"`);
        res.send(JSON.stringify(notebook, null, 2));
      } else if (format === "yaml" || format === "json") {
        res.status(501).json({ error: "Format not yet implemented" });
      } else {
        res.status(400).json({ error: "Unsupported format" });
      }
    } catch (error) {
      console.error("Export error:", error);
      res.status(500).json({ 
        error: "Failed to export",
        message: error instanceof Error ? error.message : "Unknown error",
      });
    }
  });

  return httpServer;
}
